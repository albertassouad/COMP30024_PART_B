import copy
import boomzones
import math
from itertools import count
import random



#Class that represents the board
# The board is the state
class Board:

	# dimension of a board
	HEIGHT = 8
	WIDTH = 8
	_ids = count(0) # count number of boards


	# A board is initialized with the squares it consists of
	# These squares may be unoccupied, occupied by a stack of black tokens, or occupied by a stack 
	# of white tokens
	def __init__(self, squares, to_=None, from_=None, boom_at=None):
		self.id = next(self._ids)
		# self.parent = parent
		self.squares = squares
		# This operation is only performed once when board is initialized
		# Stack is used to save time
		self.stack_list, self.token_count = self.get_stacks()

		# variables that store information about the move we're making 
		# the coordinate we're moving to/from and if we boom
		self.to_ = to_
		self.from_ = from_
		self.boom_at = boom_at
	
	#counts tokens and returns a list of all stacks on a given board
	def get_stacks(self):
		stack_list = [] 
		token_count = 0
		for i in range(Board.HEIGHT):
			for j in range(Board.WIDTH):
				if self.squares[i][j] != '':
					stack_list.append(self.squares[i][j])
					token_count += self.squares[i][j].size
		
		return stack_list, token_count

	# return lkist of stack of same colour
	def get_stacks_1colour(self, token_colour):
		stack_list = [] 
		token_count = 0
		for i in range(Board.HEIGHT):
			for j in range(Board.WIDTH):
				if self.squares[i][j] != '' and self.squares[i][j].player_white == token_colour:
					stack_list.append(self.squares[i][j])
		
		return stack_list
	
	# vector of piece counts
	#[#whites, #blacks]
	def vector_form(self, player_white):
		out_vec = []

		white_tokens = [0]
		black_tokens = [0]

		for s in self.stack_list: 
			if s.player_white == True:
				white_tokens[0] +=  s.size
			else:
				black_tokens[0] += s.size

		# outvec = white_tokens + black_tokens 
		outvec = white_tokens + black_tokens + [float(player_white)]


		return [outvec]

	# Creates a brand new board with white and black tokes in starting positions
	def new_board():

		blacks = [[1,0,7], [1,1,7],   [1,3,7], [1,4,7],   [1,6,7], [1,7,7],
         			[1,0,6], [1,1,6],   [1,3,6], [1,4,6],   [1,6,6], [1,7,6]]

		whites = [[1,0,1], [1,1,1],   [1,3,1], [1,4,1],   [1,6,1], [1,7,1],
         			[1,0,0], [1,1,0],   [1,3,0], [1,4,0],   [1,6,0], [1,7,0]]

     
        # empty board with all squares ''
		squares = Board.empty_board()
		# adds white stacks to the
		for w in whites:
			x = w[1]
			y = w[2]
			# Fill this square with a white stack
			squares[x][y] = Stack(x, y, w[0], True)
		# adds black stacks to the board
		for b in blacks:
			x = b[1]
			y = b[2]
			# Fill this square with a black stack
			squares[x][y] = Stack(x, y, b[0], False)

		return Board(squares)


	# function to initialize an empty board
	def empty_board():
		squares = []
		for i in range(Board.HEIGHT):
			row = []
			for j in range(Board.HEIGHT):
				# '' signify squares that are unoccupied by stacks 
				row.append('')
			squares.append(row)
		return squares


	# Creates a copy of the squares on this board and copies of the stack on occupied squares
	def copy_squares(self):
		new_squares = []
		for i in range(Board.HEIGHT):
			row = []
			for j in range(Board.WIDTH):
				# If a stack occupies this square
				if self.squares[i][j] != '':
					# print(self.squares[i][j])
					# Create a copy of the stack that occupies that square
					row.append(self.squares[i][j].copy_stack())
				else: 
					row.append('')
			
			new_squares.append(row)
		
		return new_squares


	# Takes the new stack generated by a move, and creates a new board with 
	# that move taken into account
	def update_board(self, new_stack):
		# Position of the new stack
		new_x = new_stack.x
		new_y = new_stack.y
		# Size of the new stack
		tokens_moved = new_stack.size
		# Copy board just returns the squares of stacks on the board
		# New squares stores the layout of the old board
		new_squares = self.copy_squares()
		# Postion that new stack will occupy
		# We check this position to see whats in it
		new_position = new_squares[new_x][new_y]
		# Check if the position is already occupied
		if new_position != '':
		# If the position is occupied by a stack of a different player_white, we abandon the move 
			if new_position.player_white != new_stack.player_white:
			# if new_position.player_white == "black":
				return None
		# If the position is occupied by a white stack, we add our new stack to that stack
			else: 
				# new position is alreadya copy
				new_squares[new_x][new_y] = new_position.update_stack(tokens_moved)
		# If the position is unoccupied assign our new stack to it
		else:

			new_squares[new_x][new_y] = new_stack

		# Edit the position this stack has moved from
		# We check the parent stack to see the previous position of this new stack
		old_x = new_stack.parent.x
		old_y = new_stack.parent.y
		# As new_squares is the layout of the old board, we have to update this position
		old_position = new_squares[old_x][old_y]
	
		# Subtract the number of tokens that were moved from that position stack
		new_squares[old_x][old_y] = old_position.update_stack(-tokens_moved)
		# Make sure we know which was moved to form this board
		return Board(new_squares, new_stack, new_stack.parent)


	
	# Create all the possible board arrangements that can result from this board
	def possible_moves(self, player_white, maximizingPlayer):
	
		moves = []
		boomed = set()
		
		# if player_white == "white":
		# 	player_white = True
		# else:
		# 	player_white = False
		# Create a list of every resulting board from every move for each stack
		for s in self.stack_list: 
			# make sure stack being moved is the colour of the player
			if s.player_white == player_white:
				moves.extend(s.possible_moves(self, boomed = boomed))

		
		# if len(moves) == 0:
		# 	return None

		# return moves in descending order if maximizing player - consider best moves first
		# return moves in ascending order if minimizing player - consider worst moves first
		if maximizingPlayer:
			moves.sort(key=lambda x: x.evaluation(player_white), reverse=True)
			return moves
		else:
			moves.sort(key=lambda x: x.evaluation(player_white), reverse=False)

			return moves

	


	"""
	* input: board state and color
	* return list of boomgroup of the input color
	* a boomgroup is formed by adjacent neighboors
	"""
	def boomgroupCalc(self, player_white):
		tokens = self.get_stacks_1colour(player_white) # list of stack of same color
		done = set()
		groups = []
		for stack in tokens:
			if not stack in done:
				# temporary list of tokens without stacks already visited
				tokens_temp = set(copy.copy(tokens))
				# set difference with done so distance with stacks in done is not calculated
				tokens_temp.difference(done) 
				group = set()
				group.add(stack)

				# if euclidean distance is less than sqrt(2), other is adjacent to stack
				for other in tokens_temp:
					euc_dist = math.sqrt((stack.x - other.x)**2 + (stack.y - other.y)**2)
					if euc_dist <= math.sqrt(2): 
						group.add(other)
				

				done.update(group) # update done set
				groups.append(group)

			if len(done) == len(tokens): break # if all tokens have been visited

		return groups

	"""	
	* input: list of boomgroups
	* return number of boomgroup and average number of token per group	
	* 
	"""
	def boomgroup_average(self, boomgroups):
		# compute average number of token per group
		average = 0
		for group in boomgroups:
			for stack in group:
				average += stack.size
		average = average/len(groups)

		return len(boomgroups), average



	"""
	* input: list of boomgroups
	* return dictionary with position as key and boomloss as value
	* goal is to find critical positions
	* boomloss is number of token loss if boom at this position
	"""
	def count_boomloss(self,boomgroups):
		boomloss_counts = {} # key = position : value = boomloss/number of tokens affected

		# list of boomspots for each group and
		for group in boomgroups:

			# get a list of boomspot for each group and count number of token in that group = boomloss
			boomspot = set()
			boomloss = 0
			for stack in group:
				boomspot.update(self.boomSpotCalc(stack))
				boomloss += stack.size

			for position in boomspot:
				if position not in boomloss_counts: # if key is not in dictionary
					boomloss_counts.setdefault(position, boomloss)
				else: boomloss_counts[position] += boomloss

		return boomloss_counts

	"""
	* input: stack
	* return boomspots of this stack
	"""
	def boomSpotCalc(self, stack):

		spots = set()

		x = stack.x
		y = stack.y

		for i in range(x-1, x+2):
				for j in range(y-1, y+2):
					# spot has to be on board and (empty or another colour)
					if (stack.onboard(i,j) and (self.squares[i][j] == '' or self.squares[i][j].player_white != stack.player_white)):
						spots.add((i,j))

		return spots


	def y_diff(self):
		

		max_white = 0
		min_black = 8

		for stack in self.stack_list:
			if stack.player_white:
				if stack.y > max_white:
					max_white = stack.y
			else:
				if stack.y < min_black:
					min_black = stack.y

		return abs(max_white - min_black)

		 


	
	"""
	* input: boomloss value dictionnary
	* return closer stack to opponent postion with largest boomvalue
	* explore this move first for better move ordering
	"""
	def best_stack(self, boomloss_dict, colour):

		# TODO, check if stack size is smaller than boomloss
		
		# get position with highest boomloss value
		opp_target = max(boomloss_dict, key=boomloss_dict.get) 


		stacks = self.get_stacks_1colour(player_white) # list of stack of same color

		best_stack = NULL
		distance = 100
		avg_dist = 0

		# find closer stack to target
		for stack in stacks[1:]:
			# manhatan distance
			distance = (math.abs(stack.x - opp_target[0]) + math.abs(stack.y - opp_target[1]))/stack.size
			avg_dist += distance
			if distance < best_distance:
				best_stack = stack

		avg_dist = avg_dist / len(stacks)
		return best_stack



	

	def neighbours(self, stack):

		count = 0
		x = stack.x
		y = stack.y
		for i in range(x-1, x+2):
			if i >= 0 and i <= 7:
				for j in range(y-1, y+2):
					if j >= 0 and j <= 7:
						if self.squares[i][j] != '' and (i,j) != (x, y):
							if self.squares[i][j].player_white == stack.player_white:
								# count += 1
								count += self.squares[i][j].size
		return count

	def manhattan(self, stack1, stack2):
		return abs(stack1.x - stack2.x) + abs(stack1.y - stack2.y)


	def evaluation(self, player_white):

		values = [[0,0,0,0,0,0,0,0],
					[1,1,1,1,1,1,1,1],
					[2,2,2,2,2,2,2,2],
					[2,3,3,3,3,3,3,2],
					[2,3,3,3,3,3,3,2],
					[2,2,2,2,2,2,2,2],
					[1,1,1,1,1,1,1,1],
					[0,0,0,0,0,0,0,0]]

		white_score = 0 
		black_score = 0

		best_white = None
		max_white = 0
		
		best_black = None
		max_black = 0
		# neighbour_dict = {}
		white_moves = 0 
		black_moves = 0

		white_neighbours = 0
		black_neighbours = 0

		white_dist = 0 
		black_dist = 0

		n_whites = 0
		n_blacks = 0

		for s in self.stack_list:
			n = self.neighbours(s)
			if s.player_white:
				n_whites += s.size
				white_neighbours += n
				if best_white == None:
					best_white = s
				if n >= max_white:
					max_white = n
					best_white = s
				if s.size == 1:
					white_moves += s.size*values[s.y][s.x] 
				else:
					white_moves += 2 * values[s.y][s.x]
			else:
				n_blacks += s.size
				black_neighbours += n
				if best_black == None:
					best_black = s
				if n >= max_black:
					max_black = n
					best_black = s
				if s.size == 1:
					black_moves += s.size*values[s.y][s.x]
				else:
					black_moves +=  2 * values[s.y][s.x] 

		if n_whites == 0 and n_blacks == 0:
			white_score = 0
			black_score = 0
		elif n_whites != 0 and n_blacks == 0:
			white_score = 100000000000000000
		elif n_whites == 0 and n_blacks != 0:
			black_score = 100000000000000000
		else:
			for s in self.stack_list: 

				if s.player_white == True:
					white_dist += self.manhattan(s, best_black)
				elif s.player_white == False:
					black_dist += self.manhattan(s, best_white)

			white_score += 1000*n_whites
			black_score += 1000*n_blacks

			white_score -= white_dist/n_whites
			black_score -= black_dist/n_whites

			white_score += white_moves
			black_score += black_moves

			
			white_score -= white_neighbours/n_whites
			black_score -= black_neighbours/n_blacks

		if player_white == True:
			return (white_score - black_score)
			# return white_score - black_score
		elif player_white == False:
			return (black_score - white_score)

	

	def outcome(self): 
		white_count = 0
		black_count = 0

		for s in self.stack_list:
			if s.player_white:
				white_count+= s.size
			else:
				black_count += s.size
		# print(white_count)
		# print(black_count)
		if white_count == 0 and black_count == 0:
			return 0
		elif black_count == 0:
			return 1
		elif white_count == 0:
			return -1
		else:
			return None



class Stack: 
	def __init__(self, x, y, size, player_white, parent=None):

		self.x = x
		self.y = y
		# size of the stack
		self.size = size
		self.player_white = player_white
		# stack from which this stack originated from
		self.parent = parent

	# Creates an exact copy of this stack
	def copy_stack(self):
		return Stack(self.x, self.y, self.size, self.player_white, self.parent)

	# Possible moves from this stack, represented as the new stacks that can result from it
	# We integrate these new stacks into the board in the Board class
	# def possible_moves(self, board, boomed, terminal=False):
	def possible_moves(self, board, boomed):

		moves = []

		for i in range(1, self.size+1): 
			# there is an up, down, left, right and boommove for each stack
			moves.extend(self.up(i, board))
			moves.extend(self.down(i, board))
			moves.extend(self.left(i, board))
			moves.extend(self.right(i, board))
			# if this tack has already been boomed for the given move
			if (self.x, self.y) not in boomed:
				moves.append(self.boom(board, boomed))

		# moves are a list of boards
		return moves
		# return new_stacks

	# String representation of the stack
	# eg 2,black 
	def to_string(self):
		if self.player_white == True:
			colour = "white"
		elif self.player_white == False:
			colour = "black"

		# return str(self.size) + "," + str(self.player_white)
		return str(self.size) + "," + colour


	def boom(self, board, boomed = None): # boomed = None when boom() is called from player class to update board
		# Find all coordinates affected by booming this stack
		coordinates = boomzones.find_boomzones(self, board.squares)
		# Add affected coordinate to boomed
		if boomed != None:
			boomed.update(coordinates)
		# Create copy of the board with copies of the Stack objects 
		new_squares = board.copy_squares()
		# Remove all stacks (stack -> '') in these coordinates
		for c in coordinates:
			# print(c)
			i = c[0]
			j = c[1]
			new_squares[i][j] = ''

		# return a new board with this layout
		return Board(new_squares, boom_at = (self.x, self.y))


	def up(self, n, board):
		moves = []
		# new_stacks = []
		# i is the  size of the move
		for i in range(1, n+1):
			# j is the number of tokens being moved
			for j in range(1, n+1):

				new_x = self.x 
				new_y = self.y + i
				# Make sure the piece keep the tokens on the board
				if self.onboard(new_x, new_y):
					# Create a new stack with these coordinte and size
					# self denotes parent of the stack we used to get here
					stack = Stack(new_x, new_y, j, self.player_white, self)
					# Returns a board with this stack integrated and old stack edited
					# if not terminal:
					#Create a board out of this stack
					updated = board.update_board(stack)
					# If the move was invalid (tried to move a white stack on a black stack 
					# None is returned
					# We never have Nones in our move array - because they're never added
					if updated!= None:
						moves.append(updated)
		# return set of moves from this
		return moves

	def down(self, n, board):
		moves = []
		# new_stacks = []
		for i in range(1, n+1):
			for j in range(1, n+1):
				new_x = self.x 
				new_y = self.y - i
				
				if self.onboard(new_x, new_y):
					stack = Stack(new_x, new_y, j, self.player_white, self)
					# new_stacks.append(stack)
					
					updated = board.update_board(stack)

					# updated = board.update_board(stack)
					if updated!= None:
						moves.append(updated)

				# else:
				# 	new_stack.append(None)
		
		# return new_stacks
		return moves


	def left(self, n, board):
		moves = []

		# new_stacks = []
		for i in range(1, n+1):
			for j in range(1, n+1):

				new_x = self.x - i
				new_y = self.y

				if self.onboard(new_x, new_y):
					stack = Stack(new_x, new_y, j, self.player_white, self)
					# new_stacks.append(stack)
					updated = board.update_board(stack)
					
					if updated != None:
						moves.append(updated)

				# else:
				# 	new_stack.append(None)
		
		# return new_stacks
		return moves


	def right(self, n, board):
		moves = []
		# new_stacks = []
		for i in range(1, n+1):
			for j in range(1, n+1):
				new_x = self.x + i
				new_y = self.y
				if self.onboard(new_x, new_y):
					stack = Stack(new_x, new_y, j, self.player_white, self)
					# new_stacks.append(stack)
					updated = board.update_board(stack)
	

					if updated!= None:
						moves.append(updated)

				# else:
				# 	new_stack.append(None)
		# return new_stacks
		return moves


	# Update the stack post move - add/remove tokens from it
	def update_stack(self, size):

		# The stack at this position is already a copy, we just edit its size
		self.size += size
		# If all tokens remove from the stack we return '' denoting empty square
		if self.size == 0:
			return ''
		else:
			return self


	def onboard(self, x, y):
		if (x >= 0 and x < 8) and (y >= 0 and y < 8):
			return True
		return False








# helper function
def player_colour(player_white):
	if player_white:
		return "white"
	return "black"


def squares_to_string(squares):
	for i in range(7,-1, -1):
		row = "["
		for j in range(8):
			if squares[j][i] != '':
				row += squares[j][i].to_string() + " "
			else: 
				row += "empty "
		row += "]"
		print(row)


# testboard = Board.new_board()
# player_white = True

# # boom
# new_stack = Stack(6, 6, 1, False)
# testboard = new_stack.boom(testboard)

# my_boomgroups = testboard.boomgroupCalc(player_white)
# # print("my_boomgroups", my_boomgroups)
# print("\n\n")
# squares_to_string(testboard.squares)
# print("\n\n")
# my_boomloss = testboard.count_boomloss(my_boomgroups)
# print("my_boomloss", my_boomloss )
# print("My avg boomloss", sum(my_boomloss.values()) / len(my_boomloss))

# opp_boomgroups = testboard.boomgroupCalc(not player_white)
# # print("opp_boomgroups", opp_boomgroups)
# print("\n\n")
# opp_boomloss = testboard.count_boomloss(opp_boomgroups)
# print("opp_boomloss", opp_boomloss )
# print("Opp avg boomloss", sum(opp_boomloss.values()) / len(opp_boomloss)) 
